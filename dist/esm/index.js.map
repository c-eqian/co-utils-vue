{"version":3,"sources":["../node_modules/@babel/runtime/helpers/typeof.js","packages/clone-deep/index.ts","index.ts"],"names":["_typeof","obj","module","exports","Symbol","iterator","constructor","prototype","__esModule"],"mappings":";AAAA,SAASA,EAAQC,GAGf,OAAQC,OAAOC,QAAUH,EAAU,mBAAqBI,QAAU,iBAAmBA,OAAOC,SAAW,SAAUJ,GAC/G,cAAcA,GACZ,SAAUA,GACZ,OAAOA,GAAO,mBAAqBG,QAAUH,EAAIK,cAAgBF,QAAUH,IAAQG,OAAOG,UAAY,gBAAkBN,GACvHC,OAAOC,QAAQK,YAAa,EAAMN,OAAOC,QAAiB,QAAID,OAAOC,QAAUH,EAAQC,GAE5FC,OAAOC,QAAUH,EAASE,OAAOC,QAAQK,YAAa,EAAMN,OAAOC,QAAiB,QAAID,OAAOC;;ACkCzE,aAjBtB,IAAA,EAAA,EAAA,QAAA,kCAAA,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAIA,SAAgB,EACd,EACA,GAEA,OAAO,KAAO,EASM,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,UAAA,QAAA,gBAAA,EAbtB,QAAA,WAAA,EAaO,IAAM,EAAY,SAAoB,EAAW,GAEtD,QAFsD,IAAA,IAAA,EAAA,IAAW,SAE3C,YAAlB,EAAO,EAAA,SAAA,IAAkC,OAAX,EAAiB,OAAO,EAE1D,GAAI,EAAK,IAAI,GAAS,OAAO,EAAK,IAAI,GAEtC,IAAM,EAAY,MAAM,QAAQ,GAAW,GAAY,GAEvD,EAAK,IAAI,EAAQ,GAEjB,IAAM,EAAU,OAAO,sBAAsB,GAEzC,EAAQ,QAEV,EAAQ,QAAQ,SAAA,GACV,EAAW,EAAQ,KAES,YAA1B,EAAO,EAAA,SAAA,EAAO,KAA2C,OAAnB,EAAO,GAC/C,EAAO,GAAU,EAAO,GAGxB,EAAO,IAAU,EAAA,QAAA,WAAU,EAAO,GAAS,MAgCnD,IAAM,EAAO,OAAO,KAAK,GAczB,OAbA,EAAK,QAAQ,SAAA,GACP,EAAW,EAAK,KAES,YAAvB,EAAO,EAAA,SAAA,EAAO,KAAqC,OAAhB,EAAO,GAE5C,EAAO,IAAO,EAAA,QAAA,WAAU,EAAO,GAAM,GAGrC,EAAO,GAAO,EAAO,MAKpB,GAnEI,QAAA,UAAS;;ACnCtB,aAAA,IAAA,EAAA,MAAA,KAAA,kBAAA,OAAA,OAAA,SAAA,EAAA,EAAA,EAAA,QAAA,IAAA,IAAA,EAAA,GAAA,IAAA,EAAA,OAAA,yBAAA,EAAA,GAAA,IAAA,QAAA,EAAA,EAAA,YAAA,EAAA,WAAA,EAAA,gBAAA,EAAA,CAAA,YAAA,EAAA,IAAA,WAAA,OAAA,EAAA,MAAA,OAAA,eAAA,EAAA,EAAA,IAAA,SAAA,EAAA,EAAA,EAAA,QAAA,IAAA,IAAA,EAAA,GAAA,EAAA,GAAA,EAAA,KAAA,EAAA,MAAA,KAAA,cAAA,SAAA,EAAA,GAAA,IAAA,IAAA,KAAA,EAAA,YAAA,GAAA,OAAA,UAAA,eAAA,KAAA,EAAA,IAAA,EAAA,EAAA,EAAA,IAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,EAAA,QAAA,yBAAA","file":"index.js","sourceRoot":"..\\..\\src","sourcesContent":["function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(obj);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","/*\r\n * @Descripttion:\r\n * @version:\r\n * @Author: 十三\r\n * @Date: 2022-09-24 11:56:13\r\n * @LastEditors: 十三\r\n * @LastEditTime: 2022-11-18 20:32:57\r\n */\r\n/**\r\n * 如果是基础数据类型，直接return\r\n * 如果是引用数据类型，处理Object、Array等\r\n * @param target\r\n */\r\n// const deepClone = <T extends unknown>(target: T) : T =>{\r\n//     if (typeof target === 'object') {\r\n//         // 处理数组\r\n//         if (Array.isArray(target)) {\r\n//             return target.map(item=> deepClone(item)) as T;\r\n//         }\r\n//         // 非 数组，创建新拷贝对象\r\n//         const cloneTarget : T = {} as T;\r\n//         for (let _key in target) {\r\n//             cloneTarget[_key] = deepClone(target[_key])\r\n//         }\r\n//         return cloneTarget;\r\n//     }\r\n//     return target\r\n\r\n// }\r\n\r\nexport function isValidKey(\r\n  key: string | number | symbol,\r\n  object: object\r\n): key is keyof typeof object {\r\n  return key in object;\r\n}\r\n\r\n/**\r\n * 深拷贝\r\n * @param source\r\n * @param hash\r\n * @returns\r\n */\r\nexport const cloneDeep = <T extends unknown>(source: T, hash = new WeakMap()): T => {\r\n  // 如果不是引用类型，直接return\r\n  if (typeof source !== 'object' || source === null) return source;\r\n  // 使用hash判断循环引用问题,如果存在，则获取这个值，并返回\r\n  if (hash.has(source)) return hash.get(source);\r\n  // 判断是否是数组\r\n  const target: T = Array.isArray(source) ? ([] as T) : ({} as T);\r\n  // 哈希保存\r\n  hash.set(source, target);\r\n  // 解决Symbol类型\r\n  const symKeys = Object.getOwnPropertySymbols(source);\r\n  // 解决存在Symbol类型\r\n  if (symKeys.length) {\r\n    // 遍历\r\n    symKeys.forEach(symKey => {\r\n      if (isValidKey(symKey, symKeys)) {\r\n        // 再判断是否是引用类型\r\n        if (typeof source[symKey] !== 'object' || source[symKey] === null) {\r\n          target[symKey] = source[symKey];\r\n        } else {\r\n          // 是引用类型，使用递归\r\n          target[symKey] = cloneDeep(source[symKey], hash);\r\n        }\r\n      }\r\n    });\r\n  }\r\n  // 解决引用类型\r\n  // for (const key in source) {\r\n  //   // 判断原型上是否存在自身属性\r\n  //   if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n  //     // 在判断是是引用类型\r\n  //     if (typeof source[key] === 'object' && source[key] !== null) {\r\n  //       // 是引用类型-> 递归\r\n  //       target[key] = cloneDeep(source[key], hash);\r\n  //     } else {\r\n  //       // 不是，直接赋值\r\n  //       target[key] = source[key];\r\n  //     }\r\n  //   }\r\n  // }\r\n  // for (const key in source) {\r\n  //   // 判断原型上是否存在自身属性\r\n  //   if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n  //     // 在判断是是引用类型\r\n  //     if (typeof source[key] === 'object' && source[key] !== null) {\r\n  //       // 是引用类型-> 递归\r\n  //       target[key] = cloneDeep(source[key], hash);\r\n  //     } else {\r\n  //       // 不是，直接赋值\r\n  //       target[key] = source[key];\r\n  //     }\r\n  //   }\r\n  // }\r\n  const keys = Object.keys(source);\r\n  keys.forEach(key => {\r\n    if (isValidKey(key, keys)) {\r\n      // 在判断是是引用类型\r\n      if (typeof source[key] === 'object' && source[key] !== null) {\r\n        // 是引用类型-> 递归\r\n        target[key] = cloneDeep(source[key], hash);\r\n      } else {\r\n        // 不是，直接赋值\r\n        target[key] = source[key];\r\n      }\r\n    }\r\n  });\r\n  // 最后返回深拷贝内容\r\n  return target;\r\n};\r\n","/*\n * @Descripttion:\n * @version:\n * @Author: 十三\n * @Date: 2022-11-18 19:24:13\n * @LastEditors: 十三\n * @LastEditTime: 2022-11-18 19:52:47\n */\nexport * from './packages/clone-deep';\n"]}